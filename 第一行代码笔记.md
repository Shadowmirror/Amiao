# 第一行代码笔记

## 一、使用基础

### 日志工具的使用

Android 中的日志工具类是 Log（android.util.Log），这个类中提供了 5 个方法来供我们打印日志

1. Log.v()：用于打印哪些最为琐碎的、意义最小的日志信息 。对应级别 verbose，是 Android 日志里面级别最低的一种。
2. Log.d()：用于打印一些调试信息，这些信息对你调试程序和分析问题应该是有帮助的。对应级别 debug，比 verbose 高一级；
3. Log.i()：用于打印一些比较重要的数据，这些数据应该是你非常想看到的、可以帮你分析用户行为数据。对应级别 info，比 debug 高一级。
4. Log.w()：用于打印一些警告信息，提示程序在这个地方可能会有潜在的风险，最好去修复一下这些出现警告的地方。对应级别 warn，比 info 高一级。
5. Log.e()：用于打印程序中的错误信息，比如程序进入到了 catch 语句当中。当有错误性息打印出来的时候，一般都代表你的程序出现严重问题了，必须尽快修复。对应级别 error，比 warn 高一级。

## 二、探究活动

### 活动是什么

活动（Activity）是一种可以包含用户界面的组件，主要用于和用户进行交互。一个应用程序中可以包含零个或多个活动，但不包含任何活动的应用程序很少见。

### 活动的基本用法

### 创建一个活动

#### 1. Add No Activity

#### 2. 在 app/src/main/java/miao/kmirror/activitytest 中创建 Enpty Activity 不用勾选 Generate Layout File 和 Launcher Activity

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211123173050.png)

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211123173131.png)

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211123173154.png)

#### 创建和加载布局

#### 在 AnfroidManifest 文件中注册

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211123173847.png)

android:label 为标题栏的内容

## 活动的生命周期

### 返回栈

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/a9c39ae886bb825b6c46e59be0303bc.jpg)

### 活动状态

1. 运行状态：当一个活动位于返回栈的栈顶时，这时活动就处于运行状态。系统最不愿意回收的就是处于运行状态的活动，因为这回带来非常差的用户体验。
2. 暂停状态：不处于栈顶，仍然可见，此时就进入暂停状态。（悬浮窗）只有在内存极低的情况下，系统才会考虑回收这种活动。
3. 停止状态：当活动不在处于栈顶位置，且完全不可可见，就进入挺停止状态。系统仍然会为这种活动保存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停滞状态的活动有可能会被系统回收。
4. 销毁状态：当一个活动从放回栈中移除后就变成了销毁状态。系统会最倾向于回收处于这种状态的活动，从而保证手机的内存充足。

### 活动的生存期

* onCreate()：每个活动中我们都重写了这个方法，它会在活动第一次被创建的时候调用。你应该在这个方法中完成活动的初始化操作，比如说加载布局、绑定事件等。
* onStart()：这个方法在活动由不可见变为可见的时候调用。
* onResume()：这个方法在活动准备好和用户进行交互的时候调用。此时的活动一定是处于返回栈的栈顶，并且处于运行状态。
* onPause()：这个方法在系统准备去启动或者恢复另一个活动的时候调用。我们通常会在这个方法中将一些消耗 CPU 的资源释放掉，以及保存一些关键数据，但这个方法的执行速度一定要快，不然会影响到新的栈顶活动的使用。
* onStop()：这个方法在活动完全不可见的时候调用。它和 onPause() 方法的主要区别在于，如果启动的新活动是一个对话框式的活动，那么 onPause() 方法会得到执行，而 onStop() 方法并不会执行。
* onDestory()：这个方法在活动被销毁之前调用，之后活动的状态将变为销毁状态。
* onRestart()：这个方法在活动由停止状态变为运行状态之前调用，也就是活动被重新启动了。

** 以上 7 个方法中出了 onRestart() 方法，其他都是两两相对的，从而又可以将活动分为 3 种生存期。**

* 完整生存期：活在 onCreate() 方法和 onDestory() 方法之间所经历的，就是完整生存期。一般情况下，一个活动会在 onCreate() 方法中完成各种初始化操作，而在 onDestory() 方法中完成释放内存的操作。
* 可见生存期：活动在 onStart() 方法和 onStop() 方法之间所经历的，就是可见生存期。在可见生存期内，活动对于用户总是可见的，即便有可能无法和用户进行交互。我们可以通过这两个方法，合理地管理哪些对用户可见的资源。比如在 onStart() 方法中对资源进行加载，而在 onStop() 方法中对资源进行释放，从而保证处于停止状态的活动不会占用过多内存。
* 前台生存期：活动在 onResume() 方法和 onPause() 方法之间所经历的就是前台生存期。在前台生存期内，活动总是处于运行状态的，此时的活动是可以和用户进行交互的，我们平时看到的和接触最多的也就是这个状态下的活动。

<img src="https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211124115109.png" style="zoom:100%;" />

### 活动的启动模式

#### standart(default)

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211124171733.png)

#### singleTop

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211124171749.png)

#### singleTask

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211124171802.png)

#### singleInstance

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211124171823.png)

## 详解四种布局

### 线性布局（LinearLayout ）

LinearLayout 又称为线性布局，是一种非常常用的布局。正如它的名字所描述的一样，这个布局会将它所包含的控件在线性方向上一次排列。

可以通过指定 android:orinentation 属性指定排列方向是垂直方向排列（vertical）的还是水平方向排列的（horizontal）

### 相对布局（RelativeLayout ）

RelativeLayout 又称做相对布局，也是一种非常常用的布局。和 LinearLayout 的排列规则不同，RelativeLayout 显得更加随意些，它通过相对定位的方式让空间出现在布局的任何位置。也正因如此，RelativeLayout 中的属性非常多，不过这些属性都是有规律可循的。

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <!--
        相对于父布局定位的效果
    -->

    <Button
        android:id="@+id/button_1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentLeft="true"
        android:layout_alignParentTop="true"
        android:text="Button 1" />

    <Button
        android:id="@+id/button_2"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentRight="true"
        android:layout_alignParentTop="true"
        android:text="Button 2" />

    <Button
        android:id="@+id/button_3"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerInParent="true"
        android:text="Button 3" />

    <Button
        android:id="@+id/button_4"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentLeft="true"
        android:layout_alignParentBottom="true"
        android:text="Button 4" />

    <Button
        android:id="@+id/button_5"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentRight="true"
        android:layout_alignParentBottom="true"
        android:text="Button 5" />



</RelativeLayout>
```

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211125092308.png)

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <!--
        相对于控件定位的效果
    -->

    <Button
        android:id="@+id/button_1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_above="@+id/button_3"
        android:layout_toLeftOf="@id/button_3"
        android:text="Button 1" />

    <Button
        android:id="@+id/button_2"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_above="@id/button_3"
        android:layout_toRightOf="@id/button_3"
        android:text="Button 2" />

    <Button
        android:id="@+id/button_3"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerInParent="true"
        android:text="Button 3" />

    <Button
        android:id="@+id/button_4"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_below="@id/button_3"
        android:layout_toLeftOf="@id/button_3"
        android:text="Button 4" />

    <Button
        android:id="@+id/button_5"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_below="@id/button_3"
        android:layout_toRightOf="@id/button_3"
        android:text="Button 5" />



</RelativeLayout>
```

### 帧布局（FrameLayout ）

FrameLayout 又称帧布局，它相比于前面两种布局就简单太多了，因此它的应用场景也少了很多。这种布局没有方便的定位方式，所有的控件都会默认摆放在布局的左上角。

```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <!--
        帧布局
    -->

   <TextView
       android:layout_width="wrap_content"
       android:layout_height="wrap_content"
       android:id="@+id/text_view"
       android:text="This is TextView" />

    <ImageView
        android:id="@+id/image_view"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:src="@mipmap/ic_launcher" />


</FrameLayout>
```

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211125093056.png)

```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <!--
        帧布局
    -->

   <TextView
       android:layout_width="wrap_content"
       android:layout_height="wrap_content"
       android:id="@+id/text_view"
       android:layout_gravity="left"
       android:text="This is TextView" />

    <ImageView
        android:id="@+id/image_view"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="right"
        android:src="@mipmap/ic_launcher" />


</FrameLayout>
```

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211125093315.png)

** 总体来说，FrameLayout 由于定位方式的欠缺，导致它的应用场景也比较少 **

### 百分比布局（PercentFrameLayout）

用上再更新，初步观察为组件相对于屏幕百分比布局

## 创建自定义控件

控件和布局的继承结构

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211125095909.png)

可以看到，我们所用的所有控件都是直接或间接继承自 View 的，所用的所有布局都是直接或间接继承自 ViewGroup 的。View 是 Android 中最基本的一种 UI 组件，它可以再屏幕上绘制一块矩形区域，并能响应这块区域的各种事件，因此，我们使用的各种控件其实就是一种特殊的 View，它可以包含很多子 View 和 子 ViewGroup，是一个用于放置控件和布局的容器。

### 引入布局

尝试 Android 加入 iPhome 的界面顶部标题栏

新建 title.xml

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:background="@drawable/title_bg">

    <Button
        android:id="@+id/title_back"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_margin="5dp"
        android:background="@drawable/back_bg"
        android:layout_gravity="center"
        android:text="Back"
        android:textColor="#fff"
        tools:ignore="MissingConstraints" />

    <TextView
        android:id="@+id/title_text"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:layout_weight="1"
        android:text="Title Text"
        android:gravity="center"
        android:textColor="#fff"
        android:textSize="24sp"
        app:layout_constraintHorizontal_weight="1"
        tools:ignore="MissingConstraints" />

    <Button
        android:id="@+id/title_edit"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_margin="5dp"
        android:background="@drawable/edit_bg"
        android:layout_gravity="center"
        android:text="Edit"
        android:textColor="#fff"
        tools:ignore="MissingConstraints" />


</LinearLayout>
```

引入 title

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <include layout="@layout/title" />


</androidx.constraintlayout.widget.ConstraintLayout>
```

隐藏系统标题栏

```java
package miao.kmirror.uicustomviews;

import androidx.appcompat.app.ActionBar;
import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;

public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        ActionBar supportActionBar = getSupportActionBar();
        if(supportActionBar != null){
            supportActionBar.hide();
        }

    }
}
```

效果图：

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211125103420.png)

### 创建自定义控件

引入布局的技巧的确解决了重复编写布局代码的问题，但是如果布局中有一些控件要求能够响应事件，我们还是需要在每个活动中为这些控件单独编写一次响应事件，我们还是需要在每个活动中为这些控件单独编写一次事件注册的代码。比如说标题栏中的返回按钮，其实不管是在哪一个活动中，这个按钮的功能都是相同的，即销毁当前活动。而如果在每一个活动中都需要重新注册一遍返回按钮的点击事件，无疑会增加很多重复代码，这种情况最好是使用自定义控件的方式来解决。

新建 TitleLayout 继承自 LinearLayout，让它成为我们自定义的标题栏控件，代码如下

```java
package miao.kmirror.uicustomviews;

import android.content.Context;
import android.text.Layout;
import android.util.AttributeSet;
import android.view.LayoutInflater;
import android.widget.LinearLayout;

import androidx.annotation.Nullable;

public class TitleLayout extends LinearLayout {
    // 我们重写了 LinearLayout 中带有两个参数的构造函数，在布局中引入 TitleLayout
    // 就会调用这个构造函数。然后在这个构造函数中需要对标栏布局进行动态加载，这就要借助
    // LayoutInflater 来实现了。
    public TitleLayout(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        // LayoutInflater 的 from() 方法可以构建出一个 LayoutInflater 对象，
        // 然后调用 inflate() 方法就可以动态加载一个布局文件
        // inflate() 方法接收两个参数
        //  第一个参数是要加载的布局文件的 id，这里我们传入的是 R.layout.title
        //  第二个参数是给加载好的布局再添加一个父布局，这里我们想要指定 TitleLayout
        //  于是直接传入 this
        LayoutInflater.from(context).inflate(R.layout.title, this);
    }
}

```

现在自定义控件已经创建好了，然后我们需要再布局文件中添加这个自定义控件，修改 activity_main.xml 中的代码，如下

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <miao.kmirror.uicustomviews.TitleLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        tools:ignore="MissingConstraints" />


</androidx.constraintlayout.widget.ConstraintLayout>
```

添加自定义控件和添加普通控件的方式基本是一样的，只不过添加自定义控件的时候，我们需要指明 ** 控件的完整类名 **，包名在这里是不可以省略的。

重新运行程序，你会发现此时效果和使用引入布局方式的效果是一样的。

为标题栏中的按钮注册点击事件，修改 TitleLayout 中的代码

```java
package miao.kmirror.uicustomviews;

import android.app.Activity;
import android.content.Context;
import android.text.Layout;
import android.util.AttributeSet;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.Button;
import android.widget.LinearLayout;
import android.widget.Toast;

import androidx.annotation.Nullable;

public class TitleLayout extends LinearLayout {
    // 我们重写了 LinearLayout 中带有两个参数的构造函数，在布局中引入 TitleLayout
    // 就会调用这个构造函数。然后在这个构造函数中需要对标栏布局进行动态加载，这就要借助
    // LayoutInflater 来实现了。
    public TitleLayout(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        // LayoutInflater 的 from() 方法可以构建出一个 LayoutInflater 对象，
        // 然后调用 inflate() 方法就可以动态加载一个布局文件
        // inflate() 方法接收两个参数
        //  第一个参数是要加载的布局文件的 id，这里我们传入的是 R.layout.title
        //  第二个参数是给加载好的布局再添加一个父布局，这里我们想要指定 TitleLayout
        //  于是直接传入 this
        LayoutInflater.from(context).inflate(R.layout.title, this);
        Button titleBack = (Button) findViewById(R.id.title_back);
        Button titleEdit = (Button) findViewById(R.id.title_edit);
        titleBack.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                ((Activity) getContext()).finish();
            }
        });
        titleEdit.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                Toast.makeText(getContext(),
                        "You clicked Eidt button",
                        Toast.LENGTH_LONG).show();
            }
        });


    }
}

```

这样，每当我们再一个布局中引入 TitleLayout 时，返回按钮和编辑按钮的点击事件就已经自动实现了。

## ListView（重点）

### ListView 的简单用

首先新建一个 ListViewTest 项目，并让 Android Studio 自动帮我们创建好活动。然后修改 activity_main.xml 中的代码，如下所示：

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <ListView
        android:id="@+id/list_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />
</androidx.constraintlayout.widget.ConstraintLayout>
```

接下来修改 MainActivity 中的代码，如下所示

```java
package miao.kmirror.listviewtest;

import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;
import android.widget.ArrayAdapter;
import android.widget.ListView;

public class MainActivity extends AppCompatActivity {

    private String[] data = {"Apple", "Banana", "Orange", "Watermelon", "Pear",
            "Grape", "Pineapple", "Strawberry", "Cherry", "Mango",
            "Apple", "Banana", "Orange", "Watermelon", "Pear",
            "Grape", "Pineapple", "Strawberry", "Cherry", "Mango",};

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        // 数组中的数据时无法直接传递给 ListView 的，我们还需要借助适配器来完成。Android 中提供了很多适配器的实现类，
        // 第一行代码用的是 ArrayAdapter。 它可以通过泛型指定为 String，然后再 ArrayAdapter 的构造函数中一次传入
        // 当前上下文、ListView 子项布局的 id，以及要适配的数据。

        // 注意：我们使用了 android.R.layout.simple_list_item_1 作为 ListView 子项布局的 id，
        // 这是一个 Android 内置的布局文件，里面只有一个 TextView，可用于简单地显示一段文本。这样适配器就构建好了
        ArrayAdapter<String> adapter = new ArrayAdapter<>(MainActivity.this, android.R.layout.simple_list_item_1, data);
        ListView listView = (ListView) findViewById(R.id.list_view);
        // 调用 ListView 的 setAdapter() 方法，将构建好的适配器对象传递进去，这样 ListView 和数据之间的关联就建立完成了。
        listView.setAdapter(adapter);
    }
}
```

### 定制 ListView 的界面

首先需要准备好一组图片，分别对应上面提供的每种水果。
接着定义一个实体类，作为 ListView 适配器的适配类型。新建类 Fruit，代码如下所示：

```java
package miao.kmirror.listviewtest;

public class Fruit {
    private String name;
    private int imageId;

    public Fruit(String name, int imageId) {
        this.name = name;
        this.imageId = imageId;
    }

    public String getName() {
        return name;
    }

    public int getImageId() {
        return imageId;
    }
}
```

Fruit 类中只有两个字段，name 表示水果的名字，imageId 表示水果对应图片的资源 id
然后需要为 ListView 的子项指定一个我们自定义的布局，在 layout 目录下新建 fruit_item.xml，代码如下所示：

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content">

    <ImageView
        android:id="@+id/fruit_image"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" />

    <TextView
        android:id="@+id/fruit_name"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_vertical"
        android:layout_marginLeft="10dp" />
</LinearLayout>
```

在这个布局中，我们定义了一个 ImageView 用于显示水果的图片，又定义了一个 TextView 用于显示水果的名称，并让 TextView 在垂直方向上居中显示。

接下来需要创建一个自定义的适配器，这个适配器继承自 ArrayAdapter，并将泛型指定为 Fruit 类。新建类 FruitAdapter，代码如下所示

```java
package miao.kmirror.listviewtest;

import android.annotation.SuppressLint;
import android.content.Context;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.ImageView;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.util.List;

public class FruitAdapter extends ArrayAdapter<Fruit> {
    private int resourceId;

    // FruitAdapter 重写了父类的一组构造函数，用于将上下文、ListView 子项布局的 id 和数据都传递进来。
    public FruitAdapter(@NonNull Context context, int resource, @NonNull List<Fruit> objects) {
        super(context, resource, objects);
        resourceId = resource;
    }

    // 重写 getView() 方法，这个方法在每个子项被滚动到屏幕内的时候会被调用。在 getView() 方法中，首先通过 getItem()
    // 方法得到当前项的 Fruit 实例，然后使用 LayoutInflater 来为这个子项加载我们传入的布局。

    @NonNull
    @Override
    public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) {
        Fruit fruit = getItem(position);
        @SuppressLint("ViewHolder") View view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false);
        ImageView imageView = view.findViewById(R.id.fruit_image);
        TextView textView =  view.findViewById(R.id.fruit_name);
        System.out.println(fruit.getName());
        imageView.setImageResource(fruit.getImageId());
        textView.setText(fruit.getName());
        return view;
    }
}
```

getView() 详解：看图

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211125143920.png)

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211125143955.png)

这里 LayoutInflater 的 inflate() 方法接收 3 个参数，前两个参数我们已经知道什么意思了，第三个参数指定成 false，表示只让我们在父布局中声明的 layout 属性生效，但不会为这个 View 添加父布局，因为一旦 View 有了父布局之后，它就不能再添加到 ListView 中了。

下面修改 MainActivity 中的代码，如下所示：

``` java
public class MainActivity extends AppCompatActivity {

    private List<Fruit> fruitList = new ArrayList<>();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initFruits();
        FruitAdapter adapter = new FruitAdapter(MainActivity.this, R.layout.fruit_item, fruitList);
        ListView listView = (ListView) findViewById(R.id.list_view);
        listView.setAdapter(adapter);
    }

    private void initFruits() {
        for (int i = 0; i < 2; i++) {
            Fruit apple = new Fruit("Apple", R.drawable.apple_pic);
            fruitList.add(apple);
            Fruit banana = new Fruit("Apple", R.drawable.banana_pic);
            fruitList.add(banana);
            Fruit orange = new Fruit("Orange", R.drawable.orange_pic);
            fruitList.add(orange);
            Fruit watermelon = new Fruit("Watermelon", R.drawable.watermelon_pic);
            fruitList.add(watermelon);
            Fruit pear = new Fruit("Pear", R.drawable.pear_pic);
            fruitList.add(pear);
            Fruit grape = new Fruit("Grape", R.drawable.grape_pic);
            fruitList.add(grape);
            Fruit pineapple = new Fruit("Pineapple", R.drawable.pineapple_pic);
            fruitList.add(pineapple);
            Fruit strawberry = new Fruit("Strawberry", R.drawable.strawberry_pic);
            fruitList.add(strawberry);
            Fruit cherry = new Fruit("Cherry", R.drawable.cherry_pic);
            fruitList.add(cherry);
            Fruit mango = new Fruit("Mango", R.drawable.mango_pic);
            fruitList.add(mango);
        }
    }
}
```

### 提升ListView的运行效率

目前我们ListView的运行效率是很低的，因为在FruitAdapter 的getView() 方法中，每次都将布局重新加载了一遍，当ListView快速滚动的时候，这就会成为性能的瓶颈。

仔细观察会发现，getView() 方法中还有一个convertView 参数，这个参数用于将之前加载好的布局进行缓存，以便之后可以进行重用。修改FruitAdapter 中的代码，如下所示：

``` java

```