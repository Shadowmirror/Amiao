# 第一行代码笔记

## 一、使用基础

### 日志工具的使用

Android 中的日志工具类是 Log（android.util.Log），这个类中提供了 5 个方法来供我们打印日志

1. Log.v()：用于打印哪些最为琐碎的、意义最小的日志信息 。对应级别 verbose，是 Android 日志里面级别最低的一种。
2. Log.d()：用于打印一些调试信息，这些信息对你调试程序和分析问题应该是有帮助的。对应级别 debug，比 verbose 高一级；
3. Log.i()：用于打印一些比较重要的数据，这些数据应该是你非常想看到的、可以帮你分析用户行为数据。对应级别 info，比 debug 高一级。
4. Log.w()：用于打印一些警告信息，提示程序在这个地方可能会有潜在的风险，最好去修复一下这些出现警告的地方。对应级别 warn，比 info 高一级。
5. Log.e()：用于打印程序中的错误信息，比如程序进入到了 catch 语句当中。当有错误性息打印出来的时候，一般都代表你的程序出现严重问题了，必须尽快修复。对应级别 error，比 warn 高一级。

## 二、探究活动

### 活动是什么

活动（Activity）是一种可以包含用户界面的组件，主要用于和用户进行交互。一个应用程序中可以包含零个或多个活动，但不包含任何活动的应用程序很少见。

### 活动的基本用法

### 创建一个活动

#### 1. Add No Activity

#### 2. 在 app/src/main/java/miao/kmirror/activitytest 中创建 Empty Activity 不用勾选 Generate Layout File 和 Launcher Activity

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211123173050.png)

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211123173131.png)

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211123173154.png)

#### 创建和加载布局

#### 在 AnfroidManifest 文件中注册

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211123173847.png)

android:label 为标题栏的内容

## 活动的生命周期

### 返回栈

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/a9c39ae886bb825b6c46e59be0303bc.jpg)

### 活动状态

1. 运行状态：当一个活动位于返回栈的栈顶时，这时活动就处于运行状态。系统最不愿意回收的就是处于运行状态的活动，因为这回带来非常差的用户体验。
2. 暂停状态：不处于栈顶，仍然可见，此时就进入暂停状态。（悬浮窗）只有在内存极低的情况下，系统才会考虑回收这种活动。
3. 停止状态：当活动不在处于栈顶位置，且完全不可可见，就进入挺停止状态。系统仍然会为这种活动保存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停滞状态的活动有可能会被系统回收。
4. 销毁状态：当一个活动从放回栈中移除后就变成了销毁状态。系统会最倾向于回收处于这种状态的活动，从而保证手机的内存充足。

### 活动的生存期

* onCreate()：每个活动中我们都重写了这个方法，它会在活动第一次被创建的时候调用。你应该在这个方法中完成活动的初始化操作，比如说加载布局、绑定事件等。
* onStart()：这个方法在活动由不可见变为可见的时候调用。
* onResume()：这个方法在活动准备好和用户进行交互的时候调用。此时的活动一定是处于返回栈的栈顶，并且处于运行状态。
* onPause()：这个方法在系统准备去启动或者恢复另一个活动的时候调用。我们通常会在这个方法中将一些消耗 CPU 的资源释放掉，以及保存一些关键数据，但这个方法的执行速度一定要快，不然会影响到新的栈顶活动的使用。
* onStop()：这个方法在活动完全不可见的时候调用。它和 onPause() 方法的主要区别在于，如果启动的新活动是一个对话框式的活动，那么 onPause() 方法会得到执行，而 onStop() 方法并不会执行。
* onDestroy()：这个方法在活动被销毁之前调用，之后活动的状态将变为销毁状态。
* onRestart()：这个方法在活动由停止状态变为运行状态之前调用，也就是活动被重新启动了。

** 以上 7 个方法中出了 onRestart() 方法，其他都是两两相对的，从而又可以将活动分为 3 种生存期。**

* 完整生存期：活在 onCreate() 方法和 onDestory() 方法之间所经历的，就是完整生存期。一般情况下，一个活动会在 onCreate() 方法中完成各种初始化操作，而在 onDestory() 方法中完成释放内存的操作。
* 可见生存期：活动在 onStart() 方法和 onStop() 方法之间所经历的，就是可见生存期。在可见生存期内，活动对于用户总是可见的，即便有可能无法和用户进行交互。我们可以通过这两个方法，合理地管理哪些对用户可见的资源。比如在 onStart() 方法中对资源进行加载，而在 onStop() 方法中对资源进行释放，从而保证处于停止状态的活动不会占用过多内存。
* 前台生存期：活动在 onResume() 方法和 onPause() 方法之间所经历的就是前台生存期。在前台生存期内，活动总是处于运行状态的，此时的活动是可以和用户进行交互的，我们平时看到的和接触最多的也就是这个状态下的活动。

<img src="https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211124115109.png" style="zoom:100%;" />

### 活动的启动模式

#### standart(default)

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211124171733.png)

#### singleTop

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211124171749.png)

#### singleTask

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211124171802.png)

#### singleInstance

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211124171823.png)

## 详解四种布局

### 线性布局（LinearLayout ）

LinearLayout 又称为线性布局，是一种非常常用的布局。正如它的名字所描述的一样，这个布局会将它所包含的控件在线性方向上一次排列。

可以通过指定 android:orientation 属性指定排列方向是垂直方向排列（vertical）的还是水平方向排列的（horizontal）

### 相对布局（RelativeLayout ）

RelativeLayout 又称做相对布局，也是一种非常常用的布局。和 LinearLayout 的排列规则不同，RelativeLayout 显得更加随意些，它通过相对定位的方式让空间出现在布局的任何位置。也正因如此，RelativeLayout 中的属性非常多，不过这些属性都是有规律可循的。

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <!--
        相对于父布局定位的效果
    -->

    <Button
        android:id="@+id/button_1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentLeft="true"
        android:layout_alignParentTop="true"
        android:text="Button 1" />

    <Button
        android:id="@+id/button_2"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentRight="true"
        android:layout_alignParentTop="true"
        android:text="Button 2" />

    <Button
        android:id="@+id/button_3"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerInParent="true"
        android:text="Button 3" />

    <Button
        android:id="@+id/button_4"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentLeft="true"
        android:layout_alignParentBottom="true"
        android:text="Button 4" />

    <Button
        android:id="@+id/button_5"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentRight="true"
        android:layout_alignParentBottom="true"
        android:text="Button 5" />



</RelativeLayout>
```

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211125092308.png)

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <!--
        相对于控件定位的效果
    -->

    <Button
        android:id="@+id/button_1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_above="@+id/button_3"
        android:layout_toLeftOf="@id/button_3"
        android:text="Button 1" />

    <Button
        android:id="@+id/button_2"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_above="@id/button_3"
        android:layout_toRightOf="@id/button_3"
        android:text="Button 2" />

    <Button
        android:id="@+id/button_3"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerInParent="true"
        android:text="Button 3" />

    <Button
        android:id="@+id/button_4"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_below="@id/button_3"
        android:layout_toLeftOf="@id/button_3"
        android:text="Button 4" />

    <Button
        android:id="@+id/button_5"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_below="@id/button_3"
        android:layout_toRightOf="@id/button_3"
        android:text="Button 5" />



</RelativeLayout>
```

### 帧布局（FrameLayout ）

FrameLayout 又称帧布局，它相比于前面两种布局就简单太多了，因此它的应用场景也少了很多。这种布局没有方便的定位方式，所有的控件都会默认摆放在布局的左上角。

```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <!--
        帧布局
    -->

   <TextView
       android:layout_width="wrap_content"
       android:layout_height="wrap_content"
       android:id="@+id/text_view"
       android:text="This is TextView" />

    <ImageView
        android:id="@+id/image_view"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:src="@mipmap/ic_launcher" />


</FrameLayout>
```

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211125093056.png)

```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <!--
        帧布局
    -->

   <TextView
       android:layout_width="wrap_content"
       android:layout_height="wrap_content"
       android:id="@+id/text_view"
       android:layout_gravity="left"
       android:text="This is TextView" />

    <ImageView
        android:id="@+id/image_view"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="right"
        android:src="@mipmap/ic_launcher" />


</FrameLayout>
```

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211125093315.png)

** 总体来说，FrameLayout 由于定位方式的欠缺，导致它的应用场景也比较少 **

### 百分比布局（PercentFrameLayout）

用上再更新，初步观察为组件相对于屏幕百分比布局

## 创建自定义控件

控件和布局的继承结构

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211125095909.png)

可以看到，我们所用的所有控件都是直接或间接继承自 View 的，所用的所有布局都是直接或间接继承自 ViewGroup 的。View 是 Android 中最基本的一种 UI 组件，它可以再屏幕上绘制一块矩形区域，并能响应这块区域的各种事件，因此，我们使用的各种控件其实就是一种特殊的 View，它可以包含很多子 View 和 子 ViewGroup，是一个用于放置控件和布局的容器。

### 引入布局

尝试 Android 加入 iPhone 的界面顶部标题栏

新建 title.xml

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:background="@drawable/title_bg">

    <Button
        android:id="@+id/title_back"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_margin="5dp"
        android:background="@drawable/back_bg"
        android:layout_gravity="center"
        android:text="Back"
        android:textColor="#fff"
        tools:ignore="MissingConstraints" />

    <TextView
        android:id="@+id/title_text"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:layout_weight="1"
        android:text="Title Text"
        android:gravity="center"
        android:textColor="#fff"
        android:textSize="24sp"
        app:layout_constraintHorizontal_weight="1"
        tools:ignore="MissingConstraints" />

    <Button
        android:id="@+id/title_edit"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_margin="5dp"
        android:background="@drawable/edit_bg"
        android:layout_gravity="center"
        android:text="Edit"
        android:textColor="#fff"
        tools:ignore="MissingConstraints" />


</LinearLayout>
```

引入 title

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <include layout="@layout/title" />


</androidx.constraintlayout.widget.ConstraintLayout>
```

隐藏系统标题栏

```java
package miao.kmirror.uicustomviews;

import androidx.appcompat.app.ActionBar;
import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;

public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        ActionBar supportActionBar = getSupportActionBar();
        if(supportActionBar != null){
            supportActionBar.hide();
        }

    }
}
```

效果图：

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211125103420.png)

### 创建自定义控件

引入布局的技巧的确解决了重复编写布局代码的问题，但是如果布局中有一些控件要求能够响应事件，我们还是需要在每个活动中为这些控件单独编写一次响应事件，我们还是需要在每个活动中为这些控件单独编写一次事件注册的代码。比如说标题栏中的返回按钮，其实不管是在哪一个活动中，这个按钮的功能都是相同的，即销毁当前活动。而如果在每一个活动中都需要重新注册一遍返回按钮的点击事件，无疑会增加很多重复代码，这种情况最好是使用自定义控件的方式来解决。

新建 TitleLayout 继承自 LinearLayout，让它成为我们自定义的标题栏控件，代码如下

```java
package miao.kmirror.uicustomviews;

import android.content.Context;
import android.text.Layout;
import android.util.AttributeSet;
import android.view.LayoutInflater;
import android.widget.LinearLayout;

import androidx.annotation.Nullable;

public class TitleLayout extends LinearLayout {
    // 我们重写了 LinearLayout 中带有两个参数的构造函数，在布局中引入 TitleLayout
    // 就会调用这个构造函数。然后在这个构造函数中需要对标栏布局进行动态加载，这就要借助
    // LayoutInflater 来实现了。
    public TitleLayout(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        // LayoutInflater 的 from() 方法可以构建出一个 LayoutInflater 对象，
        // 然后调用 inflate() 方法就可以动态加载一个布局文件
        // inflate() 方法接收两个参数
        //  第一个参数是要加载的布局文件的 id，这里我们传入的是 R.layout.title
        //  第二个参数是给加载好的布局再添加一个父布局，这里我们想要指定 TitleLayout
        //  于是直接传入 this
        LayoutInflater.from(context).inflate(R.layout.title, this);
    }
}

```

现在自定义控件已经创建好了，然后我们需要再布局文件中添加这个自定义控件，修改 activity_main.xml 中的代码，如下

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <miao.kmirror.uicustomviews.TitleLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        tools:ignore="MissingConstraints" />


</androidx.constraintlayout.widget.ConstraintLayout>
```

添加自定义控件和添加普通控件的方式基本是一样的，只不过添加自定义控件的时候，我们需要指明 ** 控件的完整类名 **，包名在这里是不可以省略的。

重新运行程序，你会发现此时效果和使用引入布局方式的效果是一样的。

为标题栏中的按钮注册点击事件，修改 TitleLayout 中的代码

```java
package miao.kmirror.uicustomviews;

import android.app.Activity;
import android.content.Context;
import android.text.Layout;
import android.util.AttributeSet;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.Button;
import android.widget.LinearLayout;
import android.widget.Toast;

import androidx.annotation.Nullable;

public class TitleLayout extends LinearLayout {
    // 我们重写了 LinearLayout 中带有两个参数的构造函数，在布局中引入 TitleLayout
    // 就会调用这个构造函数。然后在这个构造函数中需要对标栏布局进行动态加载，这就要借助
    // LayoutInflater 来实现了。
    public TitleLayout(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        // LayoutInflater 的 from() 方法可以构建出一个 LayoutInflater 对象，
        // 然后调用 inflate() 方法就可以动态加载一个布局文件
        // inflate() 方法接收两个参数
        //  第一个参数是要加载的布局文件的 id，这里我们传入的是 R.layout.title
        //  第二个参数是给加载好的布局再添加一个父布局，这里我们想要指定 TitleLayout
        //  于是直接传入 this
        LayoutInflater.from(context).inflate(R.layout.title, this);
        Button titleBack = (Button) findViewById(R.id.title_back);
        Button titleEdit = (Button) findViewById(R.id.title_edit);
        titleBack.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                ((Activity) getContext()).finish();
            }
        });
        titleEdit.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                Toast.makeText(getContext(),
                        "You clicked Edit button",
                        Toast.LENGTH_LONG).show();
            }
        });


    }
}

```

这样，每当我们再一个布局中引入 TitleLayout 时，返回按钮和编辑按钮的点击事件就已经自动实现了。

## ListView（重点）

### ListView 的简单用

首先新建一个 ListViewTest 项目，并让 Android Studio 自动帮我们创建好活动。然后修改 activity_main.xml 中的代码，如下所示：

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <ListView
        android:id="@+id/list_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />
</androidx.constraintlayout.widget.ConstraintLayout>
```

接下来修改 MainActivity 中的代码，如下所示

```java
package miao.kmirror.listviewtest;

import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;
import android.widget.ArrayAdapter;
import android.widget.ListView;

public class MainActivity extends AppCompatActivity {

    private String[] data = {"Apple", "Banana", "Orange", "Watermelon", "Pear",
            "Grape", "Pineapple", "Strawberry", "Cherry", "Mango",
            "Apple", "Banana", "Orange", "Watermelon", "Pear",
            "Grape", "Pineapple", "Strawberry", "Cherry", "Mango",};

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        // 数组中的数据时无法直接传递给 ListView 的，我们还需要借助适配器来完成。Android 中提供了很多适配器的实现类，
        // 第一行代码用的是 ArrayAdapter。 它可以通过泛型指定为 String，然后再 ArrayAdapter 的构造函数中一次传入
        // 当前上下文、ListView 子项布局的 id，以及要适配的数据。

        // 注意：我们使用了 android.R.layout.simple_list_item_1 作为 ListView 子项布局的 id，
        // 这是一个 Android 内置的布局文件，里面只有一个 TextView，可用于简单地显示一段文本。这样适配器就构建好了
        ArrayAdapter<String> adapter = new ArrayAdapter<>(MainActivity.this, android.R.layout.simple_list_item_1, data);
        ListView listView = (ListView) findViewById(R.id.list_view);
        // 调用 ListView 的 setAdapter() 方法，将构建好的适配器对象传递进去，这样 ListView 和数据之间的关联就建立完成了。
        listView.setAdapter(adapter);
    }
}
```

### 定制 ListView 的界面

首先需要准备好一组图片，分别对应上面提供的每种水果。
接着定义一个实体类，作为 ListView 适配器的适配类型。新建类 Fruit，代码如下所示：

```java
package miao.kmirror.listviewtest;

public class Fruit {
    private String name;
    private int imageId;

    public Fruit(String name, int imageId) {
        this.name = name;
        this.imageId = imageId;
    }

    public String getName() {
        return name;
    }

    public int getImageId() {
        return imageId;
    }
}
```

Fruit 类中只有两个字段，name 表示水果的名字，imageId 表示水果对应图片的资源 id
然后需要为 ListView 的子项指定一个我们自定义的布局，在 layout 目录下新建 fruit_item.xml，代码如下所示：

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content">

    <ImageView
        android:id="@+id/fruit_image"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" />

    <TextView
        android:id="@+id/fruit_name"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_vertical"
        android:layout_marginLeft="10dp" />
</LinearLayout>
```

在这个布局中，我们定义了一个 ImageView 用于显示水果的图片，又定义了一个 TextView 用于显示水果的名称，并让 TextView 在垂直方向上居中显示。

接下来需要创建一个自定义的适配器，这个适配器继承自 ArrayAdapter，并将泛型指定为 Fruit 类。新建类 FruitAdapter，代码如下所示

```java
package miao.kmirror.listviewtest;

import android.annotation.SuppressLint;
import android.content.Context;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.ImageView;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.util.List;

public class FruitAdapter extends ArrayAdapter<Fruit> {
    private int resourceId;

    // FruitAdapter 重写了父类的一组构造函数，用于将上下文、ListView 子项布局的 id 和数据都传递进来。
    public FruitAdapter(@NonNull Context context, int resource, @NonNull List<Fruit> objects) {
        super(context, resource, objects);
        resourceId = resource;
    }

    // 重写 getView() 方法，这个方法在每个子项被滚动到屏幕内的时候会被调用。在 getView() 方法中，首先通过 getItem()
    // 方法得到当前项的 Fruit 实例，然后使用 LayoutInflater 来为这个子项加载我们传入的布局。

    @NonNull
    @Override
    public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) {
        Fruit fruit = getItem(position);
        @SuppressLint("ViewHolder") View view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false);
        ImageView imageView = view.findViewById(R.id.fruit_image);
        TextView textView =  view.findViewById(R.id.fruit_name);
        System.out.println(fruit.getName());
        imageView.setImageResource(fruit.getImageId());
        textView.setText(fruit.getName());
        return view;
    }
}
```

getView() 详解：看图

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211125143920.png)

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211125143955.png)

这里 LayoutInflater 的 inflate() 方法接收 3 个参数，前两个参数我们已经知道什么意思了，第三个参数指定成 false，表示只让我们在父布局中声明的 layout 属性生效，但不会为这个 View 添加父布局，因为一旦 View 有了父布局之后，它就不能再添加到 ListView 中了。

下面修改 MainActivity 中的代码，如下所示：

```java
public class MainActivity extends AppCompatActivity {

    private List<Fruit> fruitList = new ArrayList<>();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initFruits();
        FruitAdapter adapter = new FruitAdapter(MainActivity.this, R.layout.fruit_item, fruitList);
        ListView listView = (ListView) findViewById(R.id.list_view);
        listView.setAdapter(adapter);
    }

    private void initFruits() {
        for (int i = 0; i < 2; i++) {
            Fruit apple = new Fruit("Apple", R.drawable.apple_pic);
            fruitList.add(apple);
            Fruit banana = new Fruit("Apple", R.drawable.banana_pic);
            fruitList.add(banana);
            Fruit orange = new Fruit("Orange", R.drawable.orange_pic);
            fruitList.add(orange);
            Fruit watermelon = new Fruit("Watermelon", R.drawable.watermelon_pic);
            fruitList.add(watermelon);
            Fruit pear = new Fruit("Pear", R.drawable.pear_pic);
            fruitList.add(pear);
            Fruit grape = new Fruit("Grape", R.drawable.grape_pic);
            fruitList.add(grape);
            Fruit pineapple = new Fruit("Pineapple", R.drawable.pineapple_pic);
            fruitList.add(pineapple);
            Fruit strawberry = new Fruit("Strawberry", R.drawable.strawberry_pic);
            fruitList.add(strawberry);
            Fruit cherry = new Fruit("Cherry", R.drawable.cherry_pic);
            fruitList.add(cherry);
            Fruit mango = new Fruit("Mango", R.drawable.mango_pic);
            fruitList.add(mango);
        }
    }
}
```

### 提升 ListView 的运行效率

目前我们 ListView 的运行效率是很低的，因为在 FruitAdapter 的 getView() 方法中，每次都将布局重新加载了一遍，当 ListView 快速滚动的时候，这就会成为性能的瓶颈。

仔细观察会发现，getView() 方法中还有一个 convertView 参数，这个参数用于将之前加载好的布局进行缓存，以便之后可以进行重用。修改 FruitAdapter 中的代码，如下所示：

```java
public class FruitAdapter extends ArrayAdapter<Fruit> {
    private int resourceId;

    // FruitAdapter 重写了父类的一组构造函数，用于将上下文、ListView 子项布局的 id 和数据都传递进来。
    public FruitAdapter(@NonNull Context context, int resource, @NonNull List<Fruit> objects) {
        super(context, resource, objects);
        resourceId = resource;
    }

    // 重写 getView() 方法，这个方法在每个子项被滚动到屏幕内的时候会被调用。在 getView() 方法中，首先通过 getItem()
    // 方法得到当前项的 Fruit 实例，然后使用 LayoutInflater 来为这个子项加载我们传入的布局。

    @NonNull
    @Override
    public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) {
        Fruit fruit = getItem(position);
        // 这里 LayoutInflater 的 inflate() 方法接收 3 个参数，前两个参数我们已经知道什么意思了，
        // 第三个参数指定成 false，表示只让我们在父布局中声明的 layout 属性生效，但不会为这个 View 添加父布局，
        // 因为一旦 View 有了父布局之后，它就不能再添加到 ListView 中了。
        View view;
        // 如果 convertView 为 null，则使用 LayoutInflater 去加载布局，如果不为 null 则直接对 convertView 进行重用。这样就大大提高了 ListView 的运行效率
        if(convertView == null){
           view =  LayoutInflater.from(getContext()).inflate(resourceId, parent, false);
        }else{
            view = convertView;
        }
        ImageView imageView = view.findViewById(R.id.fruit_image);
        TextView textView =  view.findViewById(R.id.fruit_name);
        System.out.println(fruit.getName());
        imageView.setImageResource(fruit.getImageId());
        textView.setText(fruit.getName());
        return view;
    }
}
```

虽然现在已经不会再重复去加载布局，但是每次在 getView() 方法中还是会调用 ViewHolder 来对这部分性能进行优化，修改 FruitAdapter 的代码，如下所示

```java
public class FruitAdapter extends ArrayAdapter<Fruit> {
    private int resourceId;

    // FruitAdapter 重写了父类的一组构造函数，用于将上下文、ListView 子项布局的 id 和数据都传递进来。
    public FruitAdapter(@NonNull Context context, int resource, @NonNull List<Fruit> objects) {
        super(context, resource, objects);
        resourceId = resource;
    }

    // 重写 getView() 方法，这个方法在每个子项被滚动到屏幕内的时候会被调用。在 getView() 方法中，首先通过 getItem()
    // 方法得到当前项的 Fruit 实例，然后使用 LayoutInflater 来为这个子项加载我们传入的布局。

    @NonNull
    @Override
    public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) {
        Fruit fruit = getItem(position);
        // 这里 LayoutInflater 的 inflate() 方法接收 3 个参数，前两个参数我们已经知道什么意思了，
        // 第三个参数指定成 false，表示只让我们在父布局中声明的 layout 属性生效，但不会为这个 View 添加父布局，

        // 如果 convertView 为 null，则使用 LayoutInflater 去加载布局，如果不为 null 则直接对 convertView 进行重用。
        // 这样就大大提高了 ListView 的运行效率
        View view;
        ViewHolder viewHolder;

        if(convertView == null){
           view =  LayoutInflater.from(getContext()).inflate(resourceId, parent, false);
           viewHolder = new ViewHolder();
            viewHolder.fruitImage = (ImageView) view.findViewById(R.id.fruit_image);
            viewHolder.fruitName = (TextView) view.findViewById(R.id.fruit_name);
            // 将 ViewHolder 存储在 View 中。
            view.setTag(viewHolder);
        }else{
            view = convertView;
            // 重新获取 ViewHolder
            viewHolder = (ViewHolder) view.getTag();
        }
        viewHolder.fruitImage.setImageResource(fruit.getImageId());
        viewHolder.fruitName.setText(fruit.getName());
        return view;
    }

    class ViewHolder{
        ImageView fruitImage;
        TextView fruitName;
    }
}
```

我们新增了一个内部类 ViewHolder，用于对控件的实例进行缓存。当 convertView 为 null 的时候，创建一个 ViewHolder 对象，并将控件的实例都存放在 ViewHolder 里，然后调用 View 的 setTag() 方法，将 ViewHolder 对象存储在 View 中。当 convertView 不为 null 的时候，则调用 View 的 getTag() 方法，把 ViewHolder 重新取出。这样所有控件的实例都缓存在了 ViewHolder 里，就没有必要每次通过 findViewById() 方法来获取控件实例了。

### ListView 的点击事件

修改 MainActivity 中的代码如下：

```java
public class MainActivity extends AppCompatActivity {

    private List<Fruit> fruitList = new ArrayList<>();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initFruits();
        FruitAdapter adapter = new FruitAdapter(MainActivity.this, R.layout.fruit_item, fruitList);
        ListView listView = (ListView) findViewById(R.id.list_view);
        listView.setAdapter(adapter);
        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                Fruit fruit = fruitList.get(position);
                Toast.makeText(MainActivity.this, fruit.getName(), Toast.LENGTH_SHORT).show();
            }
        });
    }

    private void initFruits() {
        for (int i = 0; i < 2; i++) {
            Fruit apple = new Fruit("Apple", R.drawable.apple_pic);
            fruitList.add(apple);
            Fruit banana = new Fruit("Banana", R.drawable.banana_pic);
            fruitList.add(banana);
            Fruit orange = new Fruit("Orange", R.drawable.orange_pic);
            fruitList.add(orange);
            Fruit watermelon = new Fruit("Watermelon", R.drawable.watermelon_pic);
            fruitList.add(watermelon);
            Fruit pear = new Fruit("Pear", R.drawable.pear_pic);
            fruitList.add(pear);
            Fruit grape = new Fruit("Grape", R.drawable.grape_pic);
            fruitList.add(grape);
            Fruit pineapple = new Fruit("Pineapple", R.drawable.pineapple_pic);
            fruitList.add(pineapple);
            Fruit strawberry = new Fruit("Strawberry", R.drawable.strawberry_pic);
            fruitList.add(strawberry);
            Fruit cherry = new Fruit("Cherry", R.drawable.cherry_pic);
            fruitList.add(cherry);
            Fruit mango = new Fruit("Mango", R.drawable.mango_pic);
            fruitList.add(mango);
        }
    }
}
```

## RecyclerView

了解使用详细后期更新

## 编写界面的最佳实践

## 探究碎片（Fragment）

### 碎片的生命周期

和活动一样，碎片也有自己的生命周期，并且它和活动的生命周期非常相像。

#### 碎片的状态和回调

* 运行状态：当一个碎片是可见的，并且它所关联的活动正处于运行状态时，该碎片也处于运行状态。
* 暂停状态：当一个活动进入暂停状态时（由于另一个未占满屏幕的活动被添加到了栈顶），与它相关联的可见碎片就会进入到暂停状态。
* 停止状态：当一个活动进入停止状态时，与它相关联的碎片就会进入到停止状态，或者通过调用 FragmentTransaction 的 remove()、replace() 方法将碎片从活动中移除，但如果在事务提交之前调用 addToBackStack() 方法，这时的碎片也会进入停止状态。总的来说，进入停止状态的碎片对用户来说是完全不可见的，有可能会被系统回收。
* 销毁状态：碎片总是依附于活动而存在的，因此当活动被销毁时，与它相关联的碎片就会进入销毁状态。或者通过调用 FragmentTransaction 的 remove()、replace() 方法将碎片从活动移除，但在事务提交之前并没有调用 addToBackStack() 方法，这是的碎片也会进入到销毁状态。

Fragment 类中也提供了一系列的回调方法。重点看一下以下几个回调：

- onAttach()：当碎片和活动建立关联的时候调用。
- onCreateView()：为碎片创建视图（加载布局）时调用
- onActivityCreated()：确保与碎片相关联的活动一定已经创建完毕的时候调用。
- onDestroyView()：当与碎片关联的视图被移除的时候调用。
- onDetach()：当碎片和活动解除关联的时候调用。

碎片完整的生命周期视图：

<img src="https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211126093738.png" style="width=100%" />

#### 使用限定符

layout-large/activity_main.xml
layout/activity_main.xml
large 就是一个限定符，那些屏幕被认为是 large 的设备就会自动加载 layout-large 文件下的布局，而小屏幕的设备则还是会加载 layout 文件夹下的布局

Android 中常见的限定符可以参照下表

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211126102711.png)
![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211126102725.png)

#### 使用最小宽度限定符

large 到底多大？
有时我们希望可以更加灵活地为不同设备加载布局，不管它们是不是被系统认定为 large，这时就可以使用最小宽度限定符（Smallest-width Qualifierle）了。

在 res 目录下新建 layout-sw600dp 文件夹，然后在这个文件夹下新建 activity_main.xml 布局，代码如下

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <fragment
        android:id="@+id/left_fragment"
        android:name="miao.kmirror.fragmenttest.LeftFragment"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight="1" />

    <fragment
        android:id="@+id/right_fragment"
        android:name="miao.kmirror.fragmenttest.RightFragment"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight="3" />

</LinearLayout>
```

这就意味着，当程序运行在屏幕宽度大于 600dp 的设备上时，会加载 layout-sw600dp/activity_main 布局，当程序运行在屏幕宽度小于 600dp 的设备时，则仍然加载默认的 layout/activity_main 布局。

## 详解广播机制

### 广播机制简介

Android 中的每个应用程序都可以对自己感兴趣的广播进行注册，这样该程序就只会接收到自己所关心的广播内容，这些广播可能来自与系统的，也可能来自于其他应用程序的。发送广播的方法是前面学过的 Intent。而接收广播的方法则需要引入一个新的概念 —— 广播接收器（Broadcast Receiver）

Android 中的广播主要可以分为两个类型，标准广播和有序广播。

 - 标准广播 (Normal broadcasts) 是一种完全异步执行的广播，在广播发出之后，所有的广播接收器几乎都会在同一时刻接收到这条广播消息，因此它们之间没有任何先后顺序可言。这种广播的效率会比较高，但同时也意味着它是无法被截断的。标准广播的工作流程如下：
![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211129085718.png)

 - 有序广播（Ordered broadcasts）则是一种同步执行的广播，在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。所以此时的广播接收器是有先后顺序的，优先级高的广播接收器就可以先收到广播消息，并且前面的广播接收器还可以截断正在传递的广播，这样后面的广播接收器就无法收到广播消息了。有序广播的工作流程如下
![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211129090103.png)

### 接收系统广播

Android 内置了很多系统级别的广播，我们可以在应用程序中通过监听这些广播来得到各种系统的状态信息。比如手机开机完成后会发出一条广播，电池的电量发生变化会发出一条广播，时间或时区发生改变也会发出一条广播，等等。

##### 动态注册监听网络变化

注册广播的方式一般有两种，在代码中注册和在 AndroidManifest.xml 中注册，其中前者也被称为动态注册，后者也被称为静态注册。

那么该如何创建一个广播接收器呢？其实主需要新建一个类，让它继承自 BroadcastReceiver，并重写父类的 OnReceive() 方法就行了。这样当广播到来时，onReceive() 方法就会得到执行，具体的逻辑就可以在这个方法中处理。

先通过动态注册的方式编写一个能够监听网络变化的程序。

``` java
package miao.kmirror.broadcasttest;

import androidx.appcompat.app.AppCompatActivity;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.widget.Toast;

public class MainActivity extends AppCompatActivity {

    private IntentFilter intentFilter;

    private NetworkChangeRecevier networkChangeRecevier;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        intentFilter = new IntentFilter();
        // 当网络状态发生变化时，系统发出的正式一条值为 android.net.conn.CONNECTIVITY_CHANGE 的广播
        // 也就是说我们的广播接收器想监听什么广播, 就在这里添加相应的 action.
        intentFilter.addAction("android.net.conn.CONNECTIVITY_CHANGE");
        networkChangeRecevier = new NetworkChangeRecevier();
        registerReceiver(networkChangeRecevier, intentFilter);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        // 动态注册的广播接收器一定都要取消注册才行，这里我们是在 onDestroy() 方法中通过调用 unregisterReceiver()
        // 方法来实现的。
        unregisterReceiver(networkChangeRecevier);
    }

    class NetworkChangeRecevier extends BroadcastReceiver{

        @Override
        public void onReceive(Context context, Intent intent) {
            Toast.makeText(context, "network changes", Toast.LENGTH_SHORT).show();
        }
    }
}
```

提示是否有网络 (仅数据或 WIFI 单网络情况下)
``` java
package miao.kmirror.broadcasttest;

import androidx.appcompat.app.AppCompatActivity;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.os.Bundle;
import android.widget.Toast;

public class MainActivity extends AppCompatActivity {

    private IntentFilter intentFilter;

    private NetworkChangeReceiver networkChangeReceiver;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        intentFilter = new IntentFilter();
        // 当网络状态发生变化时，系统发出的正式一条值为 android.net.conn.CONNECTIVITY_CHANGE 的广播
        // 也就是说我们的广播接收器想监听什么广播, 就在这里添加相应的 action.
        intentFilter.addAction("android.net.conn.CONNECTIVITY_CHANGE");
        networkChangeReceiver = new NetworkChangeReceiver();
        registerReceiver(networkChangeReceiver, intentFilter);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        // 动态注册的广播接收器一定都要取消注册才行，这里我们是在 onDestroy() 方法中通过调用 unregisterReceiver()
        // 方法来实现的。
        unregisterReceiver(networkChangeReceiver);
    }

    class NetworkChangeReceiver extends BroadcastReceiver{

        @Override
        public void onReceive(Context context, Intent intent) {
            ConnectivityManager connectivityManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);
            NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();
            if(networkInfo != null && networkInfo.isAvailable()){
                Toast.makeText(context, "网络已启用", Toast.LENGTH_SHORT).show();
            } else{
                Toast.makeText(context, "网络已断开", Toast.LENGTH_SHORT).show();
            }
        }
    }
}
```

``` xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="miao.kmirror.broadcasttest">

    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.BroadcastTest">
        <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>
```

在 onReceive() 方法中，首先通过 getSystemService() 方法得到了 ConnectivityManager 的实例，这是一个系统服务类，专门用于管理网络连接的。然后调用它的 getActiveNetworkInfo() 方法可以得到 NetworkInfo 的实例，接着调用 NetworkInfo 的 isAvailable() 方法，就可以判断出当前是否有网络了，最后还是通过 Toast 的方式对用户进行提示。

另外，这里有一点非常重要需要说明，Android 系统为了保护用户设备的安全和隐私，做了严格的规定：如果程序需要进行一些对用户来说比较敏感的操作，就必须在配置文件中声明权限的，否则程序将会直接崩溃。比如这里的访问系统的网络状态就是需要声明的。

#### 静态注册实现开机启动

动态注册的广播接收可以自由地控制注册与注销，在灵活性方面有很大的优势，但是它也存在着一个缺点，即必须要在程序启动之后才能接收到广播，因为注册的逻辑是写在 onCreate() 方法中的。那么有没有声明办法可以让程序在未启动的情况下就能接收到广播呢？这就需要使用静态注册的方式了。

``` java
package miao.kmirror.broadcasttest;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.util.Log;
import android.widget.Toast;

public class BootCompleteReceiver extends BroadcastReceiver {

    @Override
    public void onReceive(Context context, Intent intent) {
        Toast.makeText(context, "开机已启动", Toast.LENGTH_LONG).show();
        System.out.println("miaomiaomiao");
    }
}
```

``` xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="miao.kmirror.broadcasttest">

    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.BroadcastTest">
        <receiver
            android:name=".BootCompleteReceiver"
            android:enabled="true"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.BOOT_COMPLETED" />
            </intent-filter>
        </receiver>

        <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>
```

由于大量恶意的应用程序利用这个机制在程序未启动的情况下监听系统广播，从而使任何用都可以频繁地从后台被唤醒，严重影响了用户手机的电量和性能，因此 Android 系统几乎每个版本都在削减静态注册 BroadcastReceiver 的功能。
在 Android 8.0 系统之后，所有隐式广播都不允许使用静态注册的方式来接收了。隐式广播指的是那些没有具体指定发送给哪个应用程序的广播，大多数系统广播属于隐式广播，但是少数特殊的系统广播目前仍然允许使用静态注册的方式来接收。这些特殊的系统广播列表详见 <a>https://developer.android.google.cn/guide/components/broadcast-exceptions.html。</a>

由于 Android 系统启动完成后会发出一条值为 android.intent.action.BOOT_COMPLETED 的广播，因此我们在 ```<receiver>``` 标签中又添加了一个 ```<intent-filter>``` 标签，并在里面声明了相应的 action。Android8 后必须要加入

``` xml
<intent-filter>
    <action android:name="android.intent.action.BOOT_COMPLETED" />
</intent-filter>
```

否则无效果。

### 发送自定义广播

#### 发送标准广播

在发送广播之前，我们还是需要先定一个广播接收器来准备接收此广播。因此新建一个MyBroadcastRecevier，代码如下所示

``` java

```