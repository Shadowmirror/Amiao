# 第一行代码笔记

## 一、使用基础

### 日志工具的使用

Android 中的日志工具类是Log（android.util.Log），这个类中提供了5个方法来供我们打印日志

1. Log.v()：用于打印哪些最为琐碎的、意义最小的日志信息 。对应级别verbose，是 Android 日志里面级别最低的一种。
2. Log.d()：用于打印一些调试信息，这些信息对你调试程序和分析问题应该是有帮助的。对应级别 debug，比 verbose 高一级；
3. Log.i()：用于打印一些比较重要的数据，这些数据应该是你非常想看到的、可以帮你分析用户行为数据。对应级别 info，比 debug 高一级。
4. Log.w()：用于打印一些警告信息，提示程序在这个地方可能会有潜在的风险，最好去修复一下这些出现警告的地方。对应级别 warn，比 info 高一级。
5. Log.e()：用于打印程序中的错误信息，比如程序进入到了 catch 语句当中。当有错误性息打印出来的时候，一般都代表你的程序出现严重问题了，必须尽快修复。对应级别 error，比 warn 高一级。

## 二、探究活动

### 活动是什么

活动（Activity）是一种可以包含用户界面的组件，主要用于和用户进行交互。一个应用程序中可以包含零个或多个活动，但不包含任何活动的应用程序很少见。

### 活动的基本用法

### 创建一个活动

#### 1. Add No Activity

#### 2. 在app/src/main/java/miao/kmirror/activitytest中创建Enpty Activity 不用勾选Generate Layout File和Launcher Activity

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211123173050.png)

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211123173131.png)

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211123173154.png)



#### 创建和加载布局：

1. ![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211123173311.png)

2. ![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211123173334.png)

3. #### ![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211123173610.png)

#### 在AnfroidManifest文件中注册

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211123173847.png)

android:label 为标题栏的内容



## 活动的生命周期

### 返回栈

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/a9c39ae886bb825b6c46e59be0303bc.jpg)

### 活动状态

1. 运行状态：当一个活动位于返回栈的栈顶时，这时活动就处于运行状态。系统最不愿意回收的就是处于运行状态的活动，因为这回带来非常差的用户体验。
2. 暂停状态：不处于栈顶，仍然可见，此时就进入暂停状态。（悬浮窗）只有在内存极低的情况下，系统才会考虑回收这种活动。
3. 停止状态：当活动不在处于栈顶位置，且完全不可可见，就进入挺停止状态。系统仍然会为这种活动保存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停滞状态的活动有可能会被系统回收。
4. 销毁状态：当一个活动从放回栈中移除后就变成了销毁状态。系统会最倾向于回收处于这种状态的活动，从而保证手机的内存充足。

### 活动的生存期

* onCreate()：每个活动中我们都重写了这个方法，它会在活动第一次被创建的时候调用。你应该在这个方法中完成活动的初始化操作，比如说加载布局、绑定事件等。
* onStart()：这个方法在活动由不可见变为可见的时候调用。
* onResume()：这个方法在活动准备好和用户进行交互的时候调用。此时的活动一定是处于返回栈的栈顶，并且处于运行状态。
* onPause()：这个方法在系统准备去启动或者恢复另一个活动的时候调用。我们通常会在这个方法中将一些消耗CPU的资源释放掉，以及保存一些关键数据，但这个方法的执行速度一定要快，不然会影响到新的栈顶活动的使用。
* onStop()：这个方法在活动完全不可见的时候调用。它和onPause()方法的主要区别在于，如果启动的新活动是一个对话框式的活动，那么onPause()方法会得到执行，而onStop()方法并不会执行。
* onDestory()：这个方法在活动被销毁之前调用，之后活动的状态将变为销毁状态。
* onRestart()：这个方法在活动由停止状态变为运行状态之前调用，也就是活动被重新启动了。

**以上7个方法中出了onRestart()方法，其他都是两两相对的，从而又可以将活动分为3种生存期。**

* 完整生存期：活在onCreate()方法和onDestory()方法之间所经历的，就是完整生存期。一般情况下，一个活动会在onCreate()方法中完成各种初始化操作，而在onDestory()方法中完成释放内存的操作。
* 可见生存期：活动在onStart()方法和onStop()方法之间所经历的，就是可见生存期。在可见生存期内，活动对于用户总是可见的，即便有可能无法和用户进行交互。我们可以通过这两个方法，合理地管理哪些对用户可见的资源。比如在onStart()方法中对资源进行加载，而在onStop()方法中对资源进行释放，从而保证处于停止状态的活动不会占用过多内存。
* 前台生存期：活动在onResume()方法和onPause()方法之间所经历的就是前台生存期。在前台生存期内，活动总是处于运行状态的，此时的活动是可以和用户进行交互的，我们平时看到的和接触最多的也就是这个状态下的活动。

<img src="https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211124115109.png" style="zoom:100%;" />





### 活动的启动模式

#### standart(default)

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211124171733.png)

#### singleTop

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211124171749.png)

#### singleTask

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211124171802.png)

#### singleInstance

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211124171823.png)



## 详解四种布局

### 线性布局（LinearLayout ）

LinearLayout 又称为线性布局，是一种非常常用的布局。正如它的名字所描述的一样，这个布局会将它所包含的控件在线性方向上一次排列。

可以通过指定 android:orinentation 属性指定排列方向是垂直方向排列（vertical）的还是水平方向排列的（horizontal）

### 相对布局（RelativeLayout ）

RelativeLayout 又称做相对布局，也是一种非常常用的布局。和 LinearLayout 的排列规则不同，RelativeLayout 显得更加随意些，它通过相对定位的方式让空间出现在布局的任何位置。也正因如此，RelativeLayout 中的属性非常多，不过这些属性都是有规律可循的。

```xml	
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <!--
        相对于父布局定位的效果
    -->

    <Button
        android:id="@+id/button_1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentLeft="true"
        android:layout_alignParentTop="true"
        android:text="Button 1" />

    <Button
        android:id="@+id/button_2"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentRight="true"
        android:layout_alignParentTop="true"
        android:text="Button 2" />

    <Button
        android:id="@+id/button_3"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerInParent="true"
        android:text="Button 3" />

    <Button
        android:id="@+id/button_4"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentLeft="true"
        android:layout_alignParentBottom="true"
        android:text="Button 4" />

    <Button
        android:id="@+id/button_5"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentRight="true"
        android:layout_alignParentBottom="true"
        android:text="Button 5" />



</RelativeLayout>
```

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211125092308.png)

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <!--
        相对于控件定位的效果
    -->

    <Button
        android:id="@+id/button_1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_above="@+id/button_3"
        android:layout_toLeftOf="@id/button_3"
        android:text="Button 1" />

    <Button
        android:id="@+id/button_2"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_above="@id/button_3"
        android:layout_toRightOf="@id/button_3"
        android:text="Button 2" />

    <Button
        android:id="@+id/button_3"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerInParent="true"
        android:text="Button 3" />

    <Button
        android:id="@+id/button_4"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_below="@id/button_3"
        android:layout_toLeftOf="@id/button_3"
        android:text="Button 4" />

    <Button
        android:id="@+id/button_5"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_below="@id/button_3"
        android:layout_toRightOf="@id/button_3"
        android:text="Button 5" />



</RelativeLayout>
```



### 帧布局（FrameLayout ）

FrameLayout 又称帧布局，它相比于前面两种布局就简单太多了，因此它的应用场景也少了很多。这种布局没有方便的定位方式，所有的控件都会默认摆放在布局的左上角。

```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <!--
        帧布局
    -->

   <TextView
       android:layout_width="wrap_content"
       android:layout_height="wrap_content"
       android:id="@+id/text_view"
       android:text="This is TextView" />

    <ImageView
        android:id="@+id/image_view"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:src="@mipmap/ic_launcher" />


</FrameLayout>
```

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211125093056.png)



```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <!--
        帧布局
    -->

   <TextView
       android:layout_width="wrap_content"
       android:layout_height="wrap_content"
       android:id="@+id/text_view"
       android:layout_gravity="left"
       android:text="This is TextView" />

    <ImageView
        android:id="@+id/image_view"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="right"
        android:src="@mipmap/ic_launcher" />


</FrameLayout>
```

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211125093315.png)

**总体来说，FrameLayout 由于定位方式的欠缺，导致它的应用场景也比较少**

### 百分比布局（PercentFrameLayout）

用上再更新，初步观察为组件相对于屏幕百分比布局



## 创建自定义控件

控件和布局的继承结构

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211125095909.png)



可以看到，我们所用的所有控件都是直接或间接继承自 View 的，所用的所有布局都是直接或间接继承自 ViewGroup 的。View 是 Android 中最基本的一种 UI 组件，它可以再屏幕上绘制一块矩形区域，并能响应这块区域的各种事件，因此，我们使用的各种控件其实就是一种特殊的 View，它可以包含很多子 View 和 子 ViewGroup，是一个用于放置控件和布局的容器。

### 引入布局

尝试 Android 加入 iPhome 的界面顶部标题栏

新建 title.xml 

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:background="@drawable/title_bg">

    <Button
        android:id="@+id/title_back"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_margin="5dp"
        android:background="@drawable/back_bg"
        android:layout_gravity="center"
        android:text="Back"
        android:textColor="#fff"
        tools:ignore="MissingConstraints" />

    <TextView
        android:id="@+id/title_text"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:layout_weight="1"
        android:text="Title Text"
        android:gravity="center"
        android:textColor="#fff"
        android:textSize="24sp"
        app:layout_constraintHorizontal_weight="1"
        tools:ignore="MissingConstraints" />

    <Button
        android:id="@+id/title_edit"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_margin="5dp"
        android:background="@drawable/edit_bg"
        android:layout_gravity="center"
        android:text="Edit"
        android:textColor="#fff"
        tools:ignore="MissingConstraints" />


</LinearLayout>
```

引入 title

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <include layout="@layout/title" />


</androidx.constraintlayout.widget.ConstraintLayout>
```

隐藏系统标题栏

```java
package miao.kmirror.uicustomviews;

import androidx.appcompat.app.ActionBar;
import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;

public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        ActionBar supportActionBar = getSupportActionBar();
        if(supportActionBar != null){
            supportActionBar.hide();
        }

    }
}
```

效果图：

![](https://cdn.jsdelivr.net/gh/Shadowmirror/myPhoto@main/img/20211125103420.png)

### 创建自定义控件

引入布局的技巧的确解决了重复编写布局代码的问题，但是如果布局中有一些控件要求能够响应事件，我们还是需要在每个活动中为这些控件单独编写一次响应事件，我们还是需要在每个活动中为这些控件单独编写一次事件注册的代码。比如说标题栏中的返回按钮，其实不管是在哪一个活动中，这个按钮的功能都是相同的，即销毁当前活动。而如果在每一个活动中都需要重新注册一遍返回按钮的点击事件，无疑会增加很多重复代码，这种情况最好是使用自定义控件的方式来解决。

新建 TitleLayout 继承自 LinearLayout，让它成为我们自定义的标题栏控件，代码如下

```java
package miao.kmirror.uicustomviews;

import android.content.Context;
import android.text.Layout;
import android.util.AttributeSet;
import android.view.LayoutInflater;
import android.widget.LinearLayout;

import androidx.annotation.Nullable;

public class TitleLayout extends LinearLayout {
    // 我们重写了 LinearLayout 中带有两个参数的构造函数，在布局中引入 TitleLayout 
    // 就会调用这个构造函数。然后在这个构造函数中需要对标栏布局进行动态加载，这就要借助 
    // LayoutInflater 来实现了。
    public TitleLayout(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        // LayoutInflater 的 from() 方法可以构建出一个 LayoutInflater 对象，
        // 然后调用 inflate() 方法就可以动态加载一个布局文件
        // inflate() 方法接收两个参数
        //  第一个参数是要加载的布局文件的 id，这里我们传入的是R.layout.title
        //  第二个参数是给加载好的布局再添加一个父布局，这里我们想要指定 TitleLayout
        //  于是直接传入 this
        LayoutInflater.from(context).inflate(R.layout.title, this);
    }
}

```

现在自定义控件已经创建好了，然后我们需要再布局文件中添加这个自定义控件，修改 activity_main.xml 中的代码，如下

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <miao.kmirror.uicustomviews.TitleLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        tools:ignore="MissingConstraints" />


</androidx.constraintlayout.widget.ConstraintLayout>
```

添加自定义控件和添加普通控件的方式基本是一样的，只不过添加自定义控件的时候，我们需要指明**控件的完整类名**，包名在这里是不可以省略的。

重新运行程序，你会发现此时效果和使用引入布局方式的效果是一样的。





